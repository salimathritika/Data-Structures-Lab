/*insert at beginning,insert at end,insert at given point,delete from beginning,delete from end*/
//NOT WORKING
#include<stdio.h>
#include<stdlib.h>

typedef struct
{
    int data;
    struct node *next;
}node;

node *first=NULL;

//Insert data
void insert(int n)  //WORKS
{
    node *temp=(node*)malloc(sizeof(node));
    node *curr;
    temp->next=NULL;
    temp->data=n;
    if(first==NULL)
        first=temp;
    else
    {
        for(curr=first;curr->next!=NULL;curr=curr->next);
        curr->next=temp;
    }
}

//display contents of list
void display() //WORKS
{
    node *curr;
    if(first==NULL)
        printf("\nList is empty\n");
    else
    {
        for(curr=first;curr!=NULL;curr=curr->next)
            printf("%d ",curr->data);
    }
}

void traverse()   //WORKING
{
    node *curr;
    int i=0;
    for(curr=first;curr!=NULL;curr=curr->next)
        i++;
    printf("\nList has been traversed. Number of elements in list is %d\n",i);
}

//insert in beginning
void insert_beg(int n)  //WORKING
{
    node *temp,*curr;
    temp=(node*)malloc(sizeof(node));
    temp->data=n;
    temp->next=first;
    first=temp;
}

//insert before specific key
void insert_beforekey(int n,int key) //WORKING
{
    node *temp,*prev,*curr;
    temp=(node*)malloc(sizeof(node));
    temp->data=n;
    if(first==NULL)
    {
        first=temp;
        temp->next=NULL;
    }
    else
    {
        for(curr=first,prev=first;curr->next!=NULL;prev=curr,curr=curr->next)
        {
           if(curr->data==key)
            {
                prev->next=temp;
                temp->next=curr;
            }
        }
    }
}


//insert after specific key
void insert_afterkey(int n,int key)   //WORKING
{
    node *curr,*after,*temp;
    temp=(node*)malloc(sizeof(node));
    temp->data=n;
    if(first==NULL)
        insert(n);
    else
    {
    // Find the node with the key value
    while (curr != NULL && curr->data != key) {
        curr = curr->next;
    }
    // If the key is not found in the list
    if (curr == NULL) {
        printf("Element %d not found in the list.\n", key);
        return;
    }

    // Insert the new node after the node with the key
    temp->next = curr->next;
    curr->next = temp;

    }
}

//to insert at a specific position
void insert_pos(int n,int pos)   //WORKING
{

    int i=0;
    node *curr,*temp,*prev;
    temp=(node*)malloc(sizeof(node));
    if(pos==1)
        insert_beg(n);
    else
    {
        for(curr=first,prev=first;curr->next!=NULL;prev=curr,curr=curr->next)
    {
        i++;
        if(i==pos)
        {
            temp->data=n;
            prev->next=temp;
            temp->next=curr;
            curr=temp;
        }
    }

    }

}

//delete starting nodes
int delete_beg()  //WORKING
{
    node *temp;
    temp=first;
    int a=temp->data;
    first=first->next;
    free(temp);
    return(a);
}

int delete_end() //WORKING
{
    node *prev=first,*curr=first;
    while(curr->next!=NULL)
    {
        prev=curr;
        curr=curr->next;
    }
    prev->next=NULL;
    int a=curr->data;
    free(curr);
    return a;
}

void deleteElement(int key)   //WORKING
{
    node* curr = first;
    node* prev = NULL;

    // If the first node itself holds the key to be deleted
    if (curr != NULL && curr->data == key) {
        first = curr->next;
        free(curr);
        return;
    }

    // Search for the key to be deleted, keeping track of the previous node
    while (curr != NULL && curr->data != key) {
        prev = curr;
        curr = curr->next;
    }

    // If the key is not found in the list
    if (curr == NULL) {
        printf("Element %d not found in the list.\n", key);
        return;
    }

    // Unlink the node containing the key from the list
    prev->next = curr->next;
    free(curr);
}





void reverse()  //WORKING
{
    node *temp,*curr=first->next;
    first->next=NULL;
    while(curr!=NULL)
    {
        temp=curr;
        curr=curr->next;
        temp->next=first;
        first=temp;
    }
}

// Function to swap data values of two nodes
void swapData(node* a, node* b) {
    int temp = a->data;
    a->data = b->data;
    b->data = temp;
}

// Function to perform Bubble Sort on a linked list
void Sort() {
    int swapped;
    node* curr;
    node* last = NULL;
    node *temp;

    // Handle empty list or list with only one node
    if (first == NULL || first->next == NULL) {
        return;
    }

    do {
        swapped = 0;
        curr = first;

        while (curr->next != last) {
            temp=curr->next;
            if (curr->data > temp->data) {
                swapData(curr, curr->next);
                swapped = 1;
            }
            curr = curr->next;
        }
        last = curr;
    } while (swapped);
}



int main()
{
    int opt,n,pos,i,num,ele;
    printf("Enter number of nodes in list:");
    scanf("%d",&num);
    printf("Enter %d data:\n",num);
    for(i=0;i<num;i++)
    {
        scanf("%d",&n);
        insert(n);
    }
    display();
  /*  printf("\nEnter the data to be inserted:");
    scanf("%d",&n);
    printf("\nEnter position:");
    scanf("%d",&pos);
    insert_pos(n,pos);
    display();
    printf("\nEnter the data to be inserted:");
    scanf("%d",&n);
    printf("\nEnter position:");
    scanf("%d",&pos);
    insert_pos(n,pos);

    display();
    */
   printf("\n1.To insert in beginning\n2.To insert at end\n3.To insert before a specific key\n4.To insert after a specific key\n5.To delete in beginning\n6.To delete in end\n7.To enter data at specific position\n8.To reverse list\n9.To display list\n10.To traverse list\n11.To delete specific element\n12.To sort the list\n-1.To exit");

    do
    {
        printf("\nEnter choice:\n");
    scanf("%d",&opt);
    switch(opt)
    {
    case 1:
        {
            printf("\nEnter data to be inserted:");
            scanf("%d",&n);
            insert_beg(n);
            break;
        }
    case 2:
        {
            printf("\nEnter the data to be inserted:");
            scanf("%d",&n);
            insert(n);
            break;
        }
    case 3:
        {
            printf("\nEnter the data to be inserted:");
            scanf("%d",&n);
            printf("\nEnter the data before which given data needs to be inserted:");
            scanf("%d",&pos);
            insert_beforekey(n,pos);
            break;
        }
        case 4:
        {
            printf("\nEnter the data to be inserted:");
            scanf("%d",&n);
            printf("\nEnter the data after which given data needs to be inserted:");
            scanf("%d",&pos);
            insert_beforekey(n,pos);
            break;
        }
    case 5:
        {
            printf("The data deleted is :%d",delete_beg());
            break;
        }
    case 6:
        {
            printf("The data deleted is :%d",delete_end());
            break;
        }

    case 7:
        {
            printf("\nEnter the data to be inserted:");
            scanf("%d",&n);
            printf("\nEnter position:");
            scanf("%d",&pos);
            insert_pos(n,pos);
            break;
        }
    case 8:
        {
            reverse();
            break;
        }
    case 9:
        {
            display();
            break;
        }
    case 10:
        {
            traverse();
            break;
        }
    case 11:
        {
            printf("\nEnter element to be deleted:");
            scanf("%d",&ele);
            deleteElement(ele);
            break;
        }
    case 12:
        {
            Sort();
            printf("\nList is sorted\n");
            break;
        }
    case -1:
        printf("\nExiting\n");
    default:printf("Invalid operation");
    }

    }while(opt!=-1);
}
