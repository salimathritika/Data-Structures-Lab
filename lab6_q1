#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_SIZE 100

char s[MAX_SIZE];
int top=-1;
int n;
void push(char a)
{
    if(top==MAX_SIZE-1)
        printf("\nStack is full\n");
    else
        s[++top]=a;
}

char pop()
{
    if(top==-1)
    {
        printf("\nStack is empty\n");
        return('#');
    }
    else
        return(s[top--]);
}

typedef enum{lparen,rparen,plus,minus,times,divide,mod,eos,operand}precedence;

int icp[]={19,20,12,12,13,13,13,0};
int isp[]={19,0,12,12,13,13,13,0};

precedence get_token(char c)
{
    switch(c)
    {
    case '(':return lparen;
    case ')':return rparen;
    case '+':return plus;
    case '-':return minus;
    case '*':return times;
    case '/':return divide;
    case '%':return mod;
    case '#':return eos;
    default:return operand;
    }
}

void infix2prefix(char infix[],char prefix[])
{
    n=strlen(infix);
    int i=n-1,j=0;
    precedence temp;
    push('#');

    while(i>=0)
    {
        temp=get_token(infix[i]);
        if(temp==operand)
          prefix[j++]=infix[i];
        else if(temp==lparen)
        {
            while(s[top]!=')')
                    prefix[j++]=pop();
            pop(); //to pop out left parenthesis
        }
       else if(get_token(infix[i])==eos)
        {
          // postfix[j++]=pop();
            break;
        }

        else
        {
            while(icp[temp]<isp[get_token(s[top])])
                prefix[j++]=pop();
            push(infix[i]);

        }
        i--;
    }
    while(s[top]!='#')
    prefix[j++]=pop();
}

int main()
{
    char infix[100],prefix[100];
    printf("\nEnter the infix expression:");
    scanf("%s",infix);
    infix2prefix(infix,prefix);
    printf("\nThe equivalent prefix expression is:\n");
    for(int i=n-1;i>=0;i--)
    printf("%c",prefix[i]);
}


