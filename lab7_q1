//WORKING
#include<stdio.h>
#include<stdlib.h>

typedef struct
{
    int data;
    struct node *next;
}node;

node *first=NULL;

//Insert data
void insert(int n)  //WORKS
{
    node *temp=(node*)malloc(sizeof(node));
    node *curr;
    temp->next=NULL;
    temp->data=n;
    if(first==NULL)
        first=temp;
    else
    {
        for(curr=first;curr->next!=NULL;curr=curr->next);
        curr->next=temp;
    }
}

//display contents of list
void display() //WORKS
{
    node *curr;
    if(first==NULL)
        printf("\nList is empty\n");
    else
    {
        for(curr=first;curr!=NULL;curr=curr->next)
            printf("%d ",curr->data);
    }
}

void traverse()   //WORKING
{
    node *curr;
    int i=0;
    for(curr=first;curr!=NULL;curr=curr->next)
        i++;
    printf("\nList has been traversed. Number of elements in list is %d\n",i);
}

//insert before specific key
void insert_beforekey(int n,int key) //NOT WORKING
{
    node *temp,*prev,*curr;
    temp=(node*)malloc(sizeof(node));
    temp->data=n;
    if(first==NULL)
    {
        first=temp;
        temp->next=NULL;
    }
    else
    {
        for(curr=first,prev=first;curr->next!=NULL;prev=curr,curr=curr->next)
        {
           if(curr->data==key)
            {
                prev->next=temp;
                temp->next=curr;
            }
        }
    }
}


//insert after specific key
void insert_afterkey(int n,int key)   //NOT WORKING
{
    node *curr,*after,*temp;
    temp=(node*)malloc(sizeof(node));
    temp->data=n;
    if(first==NULL)
        insert(n);
    else
    {
    // Find the node with the key value
    while (curr != NULL && curr->data != key) {
        curr = curr->next;
    }
    // If the key is not found in the list
    if (curr == NULL) {
        printf("Element %d not found in the list.\n", key);
        return;
    }

    // Insert the new node after the node with the key
    temp->next = curr->next;
    curr->next = temp;

    }
}
void deleteElement(int key)   //WORKING
{
    node* curr = first;
    node* prev = NULL;

    // If the first node itself holds the key to be deleted
    if (curr != NULL && curr->data == key) {
        first = curr->next;
        free(curr);
        return;
    }

    // Search for the key to be deleted, keeping track of the previous node
    while (curr != NULL && curr->data != key) {
        prev = curr;
        curr = curr->next;
    }

    // If the key is not found in the list
    if (curr == NULL) {
        printf("Element %d not found in the list.\n", key);
        return;
    }

    // Unlink the node containing the key from the list
    prev->next = curr->next;
    free(curr);
}





void reverse()  //WORKING
{
    node *temp,*curr=first->next;
    first->next=NULL;
    while(curr!=NULL)
    {
        temp=curr;
        curr=curr->next;
        temp->next=first;
        first=temp;
    }
}

// Function to swap data values of two nodes
void swapData(node* a, node* b) {
    int temp = a->data;
    a->data = b->data;
    b->data = temp;
}

// Function to perform Bubble Sort on a linked list
void Sort() {
    int swapped;
    node* curr;
    node* last = NULL;
    node *temp;

    // Handle empty list or list with only one node
    if (first == NULL || first->next == NULL) {
        return;
    }

    do {
        swapped = 0;
        curr = first;

        while (curr->next != last) {
            temp=curr->next;
            if (curr->data > temp->data) {
                swapData(curr, curr->next);
                swapped = 1;
            }
            curr = curr->next;
        }
        last = curr;
    } while (swapped);
}

void deleteAlternateNodes() {
    node* curr = first;
    node* temp;

    while (curr != NULL && curr->next != NULL) {
        // Store the next node of the node to be deleted
        temp = curr->next;

        // Change the next pointer of the current node to skip the next node
        curr->next = temp->next;

        // Free the memory of the deleted node
        free(temp);

        // Move to the next pair of nodes
        curr = curr->next;
    }
}

void insertSorted(int n) {
    node* temp = (node*)malloc(sizeof(node));
    temp->data=n;
    node* curr = first;
    node* prev = NULL;

    // Traverse the list to find the appropriate position
    while (curr != NULL && curr->data < n) {
        prev = curr;
        curr = curr->next;
    }

    // Insert the new node at the appropriate position
    if (prev == NULL) {
        // Insert at the beginning
        temp->next = first;
        first = temp;
    } else {
        // Insert after 'prev'
        temp->next = prev->next;
        prev->next = temp;
    }
}

int main()
{
    int opt,n,pos,i,num,ele;
    printf("Enter number of nodes in list:");
    scanf("%d",&num);
    printf("Enter %d data:\n",num);
    for(i=0;i<num;i++)
    {
        scanf("%d",&n);
        insert(n);
    }
    display();
   printf("\n1.To insert element before another element\n2.To insert element after another element\n3.To delete given data from list\n4.To traverse the list\n5.To reverse the list\n6.To sort the list\n7.To delete every alternate node\n8.To insert element in sorted list\n9.To display list\n-1.To exit");

    do
    {
        printf("\nEnter choice:\n");
    scanf("%d",&opt);
    switch(opt)
    {
    case 1:
    {
        printf("\nEnter element to be inserted:");
        scanf("%d",&ele);
        printf("\nEnter element before which data is to be inserted:");
        scanf("%d",&pos);
        insert_beforekey(ele,pos);
        break;
    }
    case 2:
    {
        printf("\nEnter element to be inserted:");
        scanf("%d",&ele);
        printf("\nEnter element after which data is to be inserted:");
        scanf("%d",&pos);
        insert_afterkey(ele,pos);
        break;
    }
    case 3:
        {
            printf("\nEnter element to be deleted:");
            scanf("%d",&ele);
            deleteElement(ele);
            break;
        }
    case 4:
        {
            traverse();
            break;
        }
    case 5:
        {
            reverse();
            break;
        }
    case 6:
        {
            Sort();
            printf("\nList is sorted\n");
            break;
        }
    case 7:
        {
            deleteAlternateNodes();
            break;
        }
    case 8:
        {
            printf("\nEnter the data to be inserted:");
            scanf("%d",&ele);
            insertSorted(ele);
            break;
        }
    case 9:
        {
            display();
            break;
        }
    case -1:
        {printf("\nExiting\n");break;}
    default:printf("Invalid operation");
    }

    }while(opt!=-1);
}
