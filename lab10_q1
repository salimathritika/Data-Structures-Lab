//WORKS
#include<stdio.h>
#include<stdlib.h>

typedef struct tree
{
    int data;
    struct tree *lchild;
    struct tree *rchild;
} tree;

tree *root;

void inorder(tree *root)
{
    if (root != NULL)
    {
        inorder(root->lchild);
        printf("%d ", root->data);
        inorder(root->rchild);
    }
}

void postorder(tree *root)
{
    if (root != NULL)
    {
        postorder(root->lchild);
        postorder(root->rchild);
        printf("%d ", root->data);
    }
}

void preorder(tree *root)
{
    if (root != NULL)
    {
        printf("%d ", root->data);
        preorder(root->lchild);
        preorder(root->rchild);
    }
}

void count_leaf(tree *root, int *cl, int *tot)
{
    if (root != NULL)
    {
        (*tot)++;
        if (root->lchild == NULL && root->rchild == NULL)
            (*cl)++;
        count_leaf(root->lchild, cl, tot);
        count_leaf(root->rchild, cl, tot);
    }
}

void create_BT()
{
    tree *curr, *temp, *prev;
    int i, n, j;
    printf("Enter no. of nodes:");
    scanf("%d", &n);
    char dir[20];
    for (j = 0; j < n; j++)
    {
        temp = (tree *)malloc(sizeof(tree));
        printf("Enter data:");
        scanf("%d", &temp->data);
        temp->lchild = NULL;
        temp->rchild = NULL;
        if (root == NULL)
            root = temp;
        else
        {
            printf("enter the direction:");
            scanf("%s", dir);
            curr = root;
            i = 0;
            while (dir[i] != '\0')
            {
                prev = curr;
                if (dir[i] == 'l' || dir[i] == 'L')
                    curr = curr->lchild;
                else
                    curr = curr->rchild;
                i++;
            }
            if (curr != NULL || dir[i] != '\0')
                printf("Invalid direction entered");
            else
            {
                if (dir[i - 1] == 'l')
                    prev->lchild = temp;
                else
                    prev->rchild = temp;
            }
        }
    }
}

int depth(tree *ptr)
{
    int ldepth = 0, rdepth = 0;
    if (ptr == NULL)
        return 0;
    else
    {
        ldepth = depth(ptr->lchild);
        rdepth = depth(ptr->rchild);
        if (ldepth > rdepth)
            return (ldepth + 1);
        else
            return (rdepth + 1);
    }
}

int main()
{
    int opt;
    do
    {
        printf("\n1.To create binary tree\n2.To find depth of tree\n3.To print inorder traversal\n4.To print postorder traversal\n5.To print preoder traversal\n6.To count number of leaf nodes\n-1.To exit\n");
        scanf("%d", &opt);
        switch (opt)
        {
        case 1:
        {
            create_BT();
            break;
        }
        case 2:
        {
            int d = depth(root);
            printf("Depth of tree=%d", d);
            break;
        }
        case 3:
        {
            inorder(root);
            break;
        }
        case 4:
        {
            postorder(root);
            break;
        }
        case 5:
        {
            preorder(root);
            break;
        }
        case 6:
        {
            int cl = 0, tot = 0;
            count_leaf(root, &cl, &tot);
            printf("Leaf nodes: %d\n", cl);
            printf("Non-leaf nodes: %d\n", (tot - cl));
            break;
        }
        case -1:
        {
            printf("Exiting\n");
            break;
        }
        default:
        {
            printf("Invalid option\n");
            break;
        }
        }
    } while (opt != -1);

    return 0;
}
