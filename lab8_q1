//WORKS

#include<stdio.h>
#include<stdlib.h>

typedef struct
{
    struct node*llink;
    int data;
    struct node*rlink;
}node;

node *first=NULL;

node* create(node *prev,int ele,node *next)   //WORKS
{
    node *temp=(node*)malloc(sizeof(node));
    temp->rlink=next;
    temp->llink=prev;
    temp->data=ele;
    return temp;
}

void create_dll(int n )   //WORKS
{
    int i,ele;
    node *last;
    printf("Enter the elements:\n");
    for(i=0;i<n;i++)
    {
        scanf("%d",&ele);
        if(first==NULL)
            first=last=create(NULL,ele,NULL);
        else
            last=last->rlink=create(last,ele,NULL);
    }

}

void display()   //WORKS
{
    node *curr;
    if(first==NULL)
        printf("\nList is empty\n");
    else
        for(curr=first;curr!=NULL;curr=curr->rlink)
            printf("%d ",curr->data);
}

void display_rev()     //WORKS
{
    node *curr;
    if(first==NULL)
        printf("\nList is empty\n");
    else
        {
            for(curr=first;curr->rlink!=NULL;curr=curr->rlink);
            for(;curr!=NULL;curr=curr->llink)
                printf("%d ",curr->data);
        }
}

void delete_specific(int ele)   //WORKS
{
    node *curr;
    node *r,*l;
    for(curr=first;curr!=NULL;curr=curr->rlink)
    {
        if(curr->data==ele)
        {
            if(curr==first)
            {
                first=first->rlink;
                first->llink=NULL;
                free(curr);
            }
            else
            {
                r=curr->rlink;
                l=curr->llink;
                l->rlink=curr->rlink;
                r->llink=curr->llink;
            }

        }
    }
}

void insert_rear(int ele)   //WORKING
{
    node *temp=(node*)malloc(sizeof(node));
    temp->data=ele;
    node *curr;
    if(first==NULL)
    {
        first=temp;
        first->rlink=NULL;
        first->llink=NULL;
    }
    for(curr=first;curr->rlink!=NULL;curr=curr->rlink);
    curr->rlink=temp;
    temp->llink=curr;
    temp->rlink=NULL;
}

int delete_rear()   //WORKING
{
    node *curr,*prev;
    int a;
    if(first==NULL)
        {printf("\nList is empty\n");return -9999;}
    else
    {
        if(first->rlink==NULL)
        {
            a=first->data;
            first=NULL;
            return(a);
        }
        else
        {
            for(curr=first;curr->rlink!=NULL;curr=curr->rlink);
        prev=curr->llink;
        prev->rlink=NULL;
        a=curr->data;
        free(curr);
        return(a);
        }

    }
}

void insert_after(int key,int data)  //WORKING
{
    node *curr,*temp;
    curr=first;
    temp=(node *)malloc(sizeof(node));
    temp->data=data;

    if(first==NULL)
        printf("\nList is empty\n");
    else
    {
        while(curr->rlink!=NULL)
        {
            if(curr->data==key)
            {
                temp->rlink=curr->rlink;
                temp->llink=curr;
                curr->rlink=temp;
            }
            curr=curr->rlink;
        }
    }
}

void insert_bef_key(int key,int data)  //WORKS
{
    node *curr,*prev,*temp;
    temp=(node*)malloc(sizeof(node));
    temp->data=data;
    curr=first;
    if(first==NULL)
        printf("\nList is empty\n");
    else if(first->data==key)
    {
        temp->rlink=first;
        temp->llink=NULL;
        first->llink=temp;
        first=temp;
    }
    else
    {
        while(curr->rlink!=NULL)
        {
            if(curr->data==key)
            {
                prev=curr->llink;
                curr->llink=temp;
                temp->rlink=curr;
                prev->rlink=temp;
            }
            curr=curr->rlink;
        }
    }
}

void insert_pos(int pos,int data)   //WORKS
{
    int i=0;
    node *curr=first;
    node *temp=(node*)malloc(sizeof(node));
    temp->data=data;
    if(first==NULL)
        printf("\nList is empty\n");
    else
    {
        while(curr->rlink!=NULL)
        {
            i++;
            if(i==pos)
            {
                insert_bef_key(curr->data,data);
            }
            curr=curr->rlink;
        }
    }
}

void traverse()  //WORKS
{
    node *curr=first;
    int i=0;
    for(curr=first;curr!=NULL;curr=curr->rlink)
        i++;
    printf("\nAfter traversing the number of nodes present is %d\n",i);
}

void rev()
{
    node* temp = NULL;
    node* curr;
    curr=first;

    while (curr != NULL) {
        temp = curr->llink;
        curr->llink = curr->rlink;
        curr->rlink = temp;
        curr = curr->llink;
    }

    if (temp != NULL) {
        first = temp->llink;
    }
    printf("\nReversed the link\n");

}


int main()
{
    int n,ele,opt,key,pos;
    printf("Enter the number of nodes:");
    scanf("%d",&n);
    create_dll(n);
    display();

    printf("\n1.To delete an element\n2.To display the list\n3.To display the list in reverse\n4.To insert element at the rear of the list\n5.To delete from rear of list\n6.To insert element after a key\n7.To insert element before a key\n8.To insert at specific position\n9.To traverse the list\n10.To reverse the list\n-1.To exit\n");
    do
    {
        printf("\nEnter choice:");
        scanf("%d",&opt);
        switch(opt)
        {
        case 1:
            {
                printf("\nEnter element to be deleted:");
                scanf("%d",&ele);
                delete_specific(ele);
                break;
            }
        case 2:
            {
                display();
                break;
            }
        case 3:
            {
                display_rev();
                break;
            }
        case 4:
            {
                printf("\nEnter element to be inserted:");
                scanf("%d",&ele);
                insert_rear(ele);
                break;
            }
        case 5:
            {
                ele=delete_rear();
                if(ele!=-9999)
                printf("\nElement deleted is %d",ele);
                break;
            }
        case 6:
            {
                printf("\nEnter key after which to be inserted:");
                scanf("%d",&key);
                printf("\nEnter data to be inserted:");
                scanf("%d",&ele);
                insert_after(key,ele);
                break;
            }
            case 7:
            {
                printf("\nEnter key before which to be inserted:");
                scanf("%d",&key);
                printf("\nEnter data to be inserted:");
                scanf("%d",&ele);
                insert_bef_key(key,ele);
                break;
            }
            case 8:
            {
                printf("\nEnter position at which data is to be inserted:");
                scanf("%d",&pos);
                printf("\nEnter data to be inserted:");
                scanf("%d",&ele);
                insert_pos(pos,ele);
                break;
            }
            case 9:
                {
                    traverse();
                    break;
                }
            case 10:
               {
                 rev();
                 break;
               }
        case -1:
            {
                printf("\nExiting\n");
                break;
            }
        default:
            printf("\nInvalid operation\n");
        }

    }while(opt!=-1);
}
