#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/*#define MAX_SIZE 100

int isOperator(char ch) {
    return (ch == '+' || ch == '-' || ch == '*' || ch == '/');
}

int getPrecedence(char op) {
    switch(op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
    }
    return 0;
}

void infixToPostfix(char infix[], char postfix[]) {
    char stack[MAX_SIZE];
    int top = -1;
    int postfixIndex = 0;

    for (int i = 0; infix[i] != '\0'; i++) {
        if (isalnum(infix[i])) {
            postfix[postfixIndex++] = infix[i];
        } else if (infix[i] == '(') {
            stack[++top] = infix[i];
        } else if (infix[i] == ')') {
            while (top >= 0 && stack[top] != '(') {
                postfix[postfixIndex++] = stack[top--];
            }
            top--; // Pop '(' from stack
        } else if (isOperator(infix[i])) {
            while (top >= 0 && getPrecedence(stack[top]) >= getPrecedence(infix[i])) {
                postfix[postfixIndex++] = stack[top--];
            }
            stack[++top] = infix[i];
        }
    }

    while (top >= 0) {
        postfix[postfixIndex++] = stack[top--];
    }

    postfix[postfixIndex] = '\0';
}

int main() {
    char infix[MAX_SIZE];
    char postfix[MAX_SIZE];

    printf("Enter an infix expression: ");
    scanf("%s", infix);

    infixToPostfix(infix, postfix);
    printf("Equivalent postfix expression: %s\n", postfix);

    return 0;
}*/
#define MAX_SIZE 100

char s[MAX_SIZE];
int top=-1;
void push(char a)
{
    if(top==MAX_SIZE-1)
        printf("\nStack is full\n");
    else
        s[++top]=a;
}

char pop()
{
    if(top==-1)
    {
        printf("\nStack is empty\n");
        return('#');
    }
    else
        return(s[top--]);
}

typedef enum{lparen,rparen,plus,minus,times,divide,mod,eos,operand}precedence;

int icp[]={20,19,12,12,13,13,13,0};
int isp[]={0,19,12,12,13,13,13,0};

precedence get_token(char c)
{
    switch(c)
    {
    case '(':return rparen;
    case ')':return lparen;
    case '+':return plus;
    case '-':return minus;
    case '*':return times;
    case '/':return divide;
    case '%':return mod;
    case '#':return eos;
    default:return operand;
    }
}

void infix2postfix(char infix[],char postfix[])
{
    int i=0,j=0;
    precedence temp;
    push('#');

    while(infix[i]!='\0')
    {
        temp=get_token(infix[i]);
        if(temp==operand)
          postfix[j++]=infix[i];
        else if(temp==rparen)
        {
            while(s[top]!='(')
                    postfix[j++]=pop();
            pop(); //to pop out left parenthesis
        }
        else if(get_token(infix[i])=='#')
        {
          // postfix[j++]=pop();
            break;
        }

        else
        {
            while(icp[temp]<=isp[get_token(s[top])])
                postfix[j++]=pop();
            push(infix[i]);

        }
        i++;
    }
    postfix[j++]=pop();
}

int main()
{
    char infix[100],postfix[100];
    printf("\nEnter the infix expression:");
    scanf("%s",infix);
    infix2postfix(infix,postfix);
    printf("\nThe equivalent postfix expression is:%s",postfix);
}
